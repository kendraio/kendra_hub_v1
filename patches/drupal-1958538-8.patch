diff --git a/includes/math-expr.inc b/includes/math-expr.inc
index beffb93..63835ca 100644
--- a/includes/math-expr.inc
+++ b/includes/math-expr.inc
@@ -1,388 +1,547 @@
 <?php
 
-/*
-================================================================================
-
-ctools_math_expr - PHP Class to safely evaluate math expressions
-Copyright (C) 2005 Miles Kaufmann <http://www.twmagic.com/>
-
-================================================================================
-
-NAME
-    ctools_math_expr - safely evaluate math expressions
-
-SYNOPSIS
-      include('ctools_math_expr.class.php');
-      $m = new ctools_math_expr;
-      // basic evaluation:
-      $result = $m->evaluate('2+2');
-      // supports: order of operation; parentheses; negation; built-in functions
-      $result = $m->evaluate('-8(5/2)^2*(1-sqrt(4))-8');
-      // create your own variables
-      $m->evaluate('a = e^(ln(pi))');
-      // or functions
-      $m->evaluate('f(x,y) = x^2 + y^2 - 2x*y + 1');
-      // and then use them
-      $result = $m->evaluate('3*f(42,a)');
-
-DESCRIPTION
-    Use the ctools_math_expr class when you want to evaluate mathematical expressions
-    from untrusted sources.  You can define your own variables and functions,
-    which are stored in the object.  Try it, it's fun!
-
-METHODS
-    $m->evalute($expr)
-        Evaluates the expression and returns the result.  If an error occurs,
-        prints a warning and returns false.  If $expr is a function assignment,
-        returns true on success.
-
-    $m->e($expr)
-        A synonym for $m->evaluate().
-
-    $m->vars()
-        Returns an associative array of all user-defined variables and values.
-
-    $m->funcs()
-        Returns an array of all user-defined functions.
-
-PARAMETERS
-    $m->suppress_errors
-        Set to true to turn off warnings when evaluating expressions
-
-    $m->last_error
-        If the last evaluation failed, contains a string describing the error.
-        (Useful when suppress_errors is on).
-
-AUTHOR INFORMATION
-    Copyright 2005, Miles Kaufmann.
-
-LICENSE
-    Redistribution and use in source and binary forms, with or without
-    modification, are permitted provided that the following conditions are
-    met:
-
-    1   Redistributions of source code must retain the above copyright
-        notice, this list of conditions and the following disclaimer.
-    2.  Redistributions in binary form must reproduce the above copyright
-        notice, this list of conditions and the following disclaimer in the
-        documentation and/or other materials provided with the distribution.
-    3.  The name of the author may not be used to endorse or promote
-        products derived from this software without specific prior written
-        permission.
-
-    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-    DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
-    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
-    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
-    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
-    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-    POSSIBILITY OF SUCH DAMAGE.
-
-*/
 
 class ctools_math_expr {
-    var $suppress_errors = false;
-    var $last_error = null;
-
-    var $v = array('e'=>2.71,'pi'=>3.14); // variables (and constants)
-    var $f = array(); // user-defined functions
-    var $vb = array('e', 'pi'); // constants
-    var $fb = array(  // built-in functions
-        'sin','sinh','arcsin','asin','arcsinh','asinh',
-        'cos','cosh','arccos','acos','arccosh','acosh',
-        'tan','tanh','arctan','atan','arctanh','atanh',
-        'pow', 'exp',
-        'sqrt','abs','ln','log',
-        'time', 'ceil', 'floor', 'min', 'max', 'round');
-
-    function ctools_math_expr() {
-        // make the variables a little more accurate
-        $this->v['pi'] = pi();
-        $this->v['e'] = exp(1);
-        drupal_alter('ctools_math_expression_functions', $this->fb);
+  var $suppress_errors = FALSE;
+  var $last_error = NULL;
+  var $errors = array();
+
+  var $v = array('e' => 2.71, 'pi' => 3.14); // variables (and constants)
+  var $f = array(); // user-defined functions
+  var $vb = array('e', 'pi'); // constants
+  var $fsimple = array( // built-in functions
+    'sin', 'sinh', 'asin', 'asinh',
+    'cos', 'cosh', 'acos', 'acosh',
+    'tan', 'tanh', 'atan', 'atanh',
+    'pow', 'exp',
+    'sqrt', 'abs', 'log',
+    'time', 'ceil', 'floor', 'round'
+  );
+  var $fb = array(
+    'ln' => array(
+      'function' => 'log',
+      'arguments' => 1,
+    ),
+    'arcsin' => array(
+      'function' => 'asin',
+      'arguments' => 1,
+    ),
+    'arcsinh' => array(
+      'function' => 'asinh',
+      'arguments' => 1,
+    ),
+    'arccos' => array(
+      'function' => 'acos',
+      'arguments' => 1,
+    ),
+    'arccosh' => array(
+      'function' => 'acosh',
+      'arguments' => 1,
+    ),
+    'arctan' => array(
+      'function' => 'atan',
+      'arguments' => 1,
+    ),
+    'arctanh' => array(
+      'function' => 'atanh',
+      'arguments' => 1,
+    ),
+    'min' => array(
+      'function' => 'min',
+      'arguments' => 2,
+      'max arguments' => 99,
+    ),
+    'max' => array(
+      'function' => 'max',
+      'arguments' => 2,
+      'max arguments' => 99,
+    ),
+    'if' => array(
+      'function' => 'ctools_math_expr_if',
+      'arguments' => 2,
+      'max arguments' => 3,
+    ),
+    'number' => array(
+      'function' => 'ctools_math_expr_number',
+      'arguments' => 1,
+    ),
+  );
+
+  /**
+   * Public constructor.
+   */
+  public function __construct() {
+    // Make the variables a little more accurate.
+    $this->v['pi'] = pi();
+    $this->v['e'] = exp(1);
+
+    // Allow modules to add custom functions.
+    // @todo -- properly document this.
+    $context = array('final' => &$this->fb);
+    drupal_alter('ctools_math_expression_functions', $this->fsimple, $context);
+
+    // Translate the older, simpler style into the newer, richer style.
+    foreach ($this->fsimple as $function) {
+      $this->fb[$function] = array(
+        'function' => $function,
+        'arguments' => 1,
+      );
     }
+  }
+
+  /**
+   * Evaluate the expression.
+   *
+   * @param string $expr The expression to evaluate.
+   * @return string
+   */
+  function evaluate($expr) {
+    $this->last_error = NULL;
+    $expr = trim($expr);
+    if (substr($expr, -1, 1) == ';') {
+      $expr = substr($expr, 0, strlen($expr) - 1);
+    } // strip semicolons at the end
+
+    // is it a variable assignment?
+    if (preg_match('/^\s*([a-z]\w*)\s*=\s*(.+)$/', $expr, $matches)) {
+      if (in_array($matches[1], $this->vb)) { // make sure we're not assigning to a constant
+        return $this->trigger("cannot assign to constant '$matches[1]'");
+      }
+      if (($tmp = $this->pfx($this->nfx($matches[2]))) === FALSE) {
+        return FALSE;
+      } // get the result and make sure it's good
+      $this->v[$matches[1]] = $tmp; // if so, stick it in the variable array
+      return $this->v[$matches[1]]; // and return the resulting value
+
+      // is it a function assignment?
+    }
+    elseif (preg_match('/^\s*([a-z]\w*)\s*\(\s*([a-z]\w*(?:\s*,\s*[a-z]\w*)*)\s*\)\s*=\s*(.+)$/', $expr, $matches)) {
+      $fnn = $matches[1]; // get the function name
+      if (isset($this->fb[$matches[1]])) { // make sure it isn't built in
+        return $this->trigger("cannot redefine built-in function '$matches[1]()'");
+      }
+      $args = explode(",", preg_replace("/\s+/", "", $matches[2])); // get the arguments
+      if (($stack = $this->nfx($matches[3])) === FALSE) {
+        return FALSE;
+      } // see if it can be converted to postfix
+      for ($i = 0; $i < count($stack); $i++) { // freeze the state of the non-argument variables
+        $token = $stack[$i];
+        if (preg_match('/^[a-z]\w*$/', $token) and !in_array($token, $args)) {
+          if (array_key_exists($token, $this->v)) {
+            $stack[$i] = $this->v[$token];
+          }
+          else {
+            return $this->trigger("undefined variable '$token' in function definition");
+          }
+        }
+      }
+      $this->f[$fnn] = array('args' => $args, 'func' => $stack);
+
+      return TRUE;
 
-    function e($expr) {
-        return $this->evaluate($expr);
+    }
+    else {
+      return trim($this->pfx($this->nfx($expr)), '"'); // straight up evaluation, woo
+    }
+  }
+
+  /**
+   * Fetch an array of variables used in the expression.
+   *
+   * @return array
+   */
+  public function vars() {
+    $output = $this->v;
+    unset($output['pi']);
+    unset($output['e']);
+
+    return $output;
+  }
+
+  /**
+   * Fetch all user defined functions in the expression.
+   *
+   * @return array
+   */
+  public function funcs() {
+    $output = array();
+    foreach ($this->f as $fnn => $dat) {
+      $output[] = $fnn . '(' . implode(',', $dat['args']) . ')';
     }
 
-    function evaluate($expr) {
-        $this->last_error = null;
-        $expr = trim($expr);
-        if (substr($expr, -1, 1) == ';') $expr = substr($expr, 0, strlen($expr)-1); // strip semicolons at the end
-        //===============
-        // is it a variable assignment?
-        if (preg_match('/^\s*([a-z]\w*)\s*=\s*(.+)$/', $expr, $matches)) {
-            if (in_array($matches[1], $this->vb)) { // make sure we're not assigning to a constant
-                return $this->trigger("cannot assign to constant '$matches[1]'");
-            }
-            if (($tmp = $this->pfx($this->nfx($matches[2]))) === false) return false; // get the result and make sure it's good
-            $this->v[$matches[1]] = $tmp; // if so, stick it in the variable array
-            return $this->v[$matches[1]]; // and return the resulting value
-        //===============
-        // is it a function assignment?
-        } elseif (preg_match('/^\s*([a-z]\w*)\s*\(\s*([a-z]\w*(?:\s*,\s*[a-z]\w*)*)\s*\)\s*=\s*(.+)$/', $expr, $matches)) {
-            $fnn = $matches[1]; // get the function name
-            if (in_array($matches[1], $this->fb)) { // make sure it isn't built in
-                return $this->trigger("cannot redefine built-in function '$matches[1]()'");
+    return $output;
+  }
+
+  // Convert infix to postfix notation
+  private function nfx($expr) {
+
+    $index = 0;
+    $stack = new ctools_math_expr_stack;
+    $output = array(); // postfix form of expression, to be passed to pfx()
+    $expr = trim(strtolower($expr));
+
+    $ops = array(
+      '+' => array(
+        'precedence' => 0,
+      ),
+      '-' => array(
+        'precedence' => 0,
+      ),
+      '*'=> array(
+        'precedence' => 1,
+      ),
+      '/'=> array(
+        'precedence' => 1,
+      ),
+      '^' => array(
+        'right' => TRUE,
+        'precedence' => 2,
+      ),
+      '_' => array(
+        'precedence' => 1,
+      ),
+      '==' => array(
+        'precedence' => -1,
+      ),
+      '!=' => array(
+        'precedence' => -1,
+      ),
+      '>=' => array(
+        'precedence' => -1,
+      ),
+      '<=' => array(
+        'precedence' => -1,
+      ),
+      '>' => array(
+        'precedence' => -1,
+      ),
+      '<' => array(
+        'precedence' => -1,
+      )
+    );
+    $expecting_op = FALSE; // we use this in syntax-checking the expression
+    // And determining when a - is a negation
+
+    while (1) { // 1 Infinite Loop ;)
+      $op = substr($expr, $index, 1); // get the first character at the current index
+      // if the second character is an =, add it to our op.
+      if (substr($expr, $index + 1, 1) == '=') {
+        $op = substr($expr, $index, 2);
+        $index++;
+      }
+      // find out if we're currently at the beginning of a number/variable/function/parenthesis/operand
+      $ex = preg_match('/^([a-z]\w*\(?|\d+(?:\.\d*)?|\.\d+|\()/', substr($expr, $index), $match);
+
+      if ($op == '-' and !$expecting_op) { // is it a negation instead of a minus?
+        $stack->push('_'); // put a negation on the stack
+        $index++;
+      }
+      elseif ($op == '_') { // we have to explicitly deny this, because it's legal on the stack
+        return $this->trigger("illegal character '_'"); // but not in the input expression
+
+      }
+      elseif ((isset($ops[$op]) || $ex) && $expecting_op) { // are we putting an operator on the stack?
+        if ($ex) { // are we expecting an operator but have a number/variable/function/opening parenthesis?
+          $op = '*';
+          $index--; // it's an implicit multiplication
+        }
+        // heart of the algorithm:
+        while ($stack->count > 0 && ($o2 = $stack->last()) && isset($ops[$o2]) && (!empty($ops[$op]['right']) ? $ops[$op]['precedence'] < $ops[$o2]['precedence'] : $ops[$op]['precedence'] <= $ops[$o2]['precedence'])) {
+          $output[] = $stack->pop(); // pop stuff off the stack into the output
+        }
+        // many thanks: http://en.wikipedia.org/wiki/Reverse_Polish_notation#The_algorithm_in_detail
+        $stack->push($op); // finally put OUR operator onto the stack
+        $index++;
+        $expecting_op = FALSE;
+
+      }
+      elseif ($op == ')' and $expecting_op) { // ready to close a parenthesis?
+        while (($o2 = $stack->pop()) != '(') { // pop off the stack back to the last (
+          if (is_null($o2)) {
+            return $this->trigger("unexpected ')'");
+          }
+          else {
+            $output[] = $o2;
+          }
+        }
+        if (preg_match("/^([a-z]\w*)\($/", $stack->last(2), $matches)) { // did we just close a function?
+          $fnn = $matches[1]; // get the function name
+          $arg_count = $stack->pop(); // see how many arguments there were (cleverly stored on the stack, thank you)
+          $output[] = $stack->pop(); // pop the function and push onto the output
+          if (isset($this->fb[$fnn])) { // check the argument count
+            $max_arguments = isset($this->fb[$fnn]['max arguments']) ? $this->fb[$fnn]['max arguments'] : $this->fb[$fnn]['arguments'];
+            if ($arg_count > $max_arguments) {
+              return $this->trigger("too many arguments ($arg_count given, $max_arguments expected)");
             }
-            $args = explode(",", preg_replace("/\s+/", "", $matches[2])); // get the arguments
-            if (($stack = $this->nfx($matches[3])) === false) return false; // see if it can be converted to postfix
-            for ($i = 0; $i<count($stack); $i++) { // freeze the state of the non-argument variables
-                $token = $stack[$i];
-                if (preg_match('/^[a-z]\w*$/', $token) and !in_array($token, $args)) {
-                    if (array_key_exists($token, $this->v)) {
-                        $stack[$i] = $this->v[$token];
-                    } else {
-                        return $this->trigger("undefined variable '$token' in function definition");
-                    }
-                }
+          }
+          elseif (array_key_exists($fnn, $this->f)) {
+            if ($arg_count != count($this->f[$fnn]['args'])) {
+              return $this->trigger("wrong number of arguments ($arg_count given, " . count($this->f[$fnn]['args']) . " expected)");
             }
-            $this->f[$fnn] = array('args'=>$args, 'func'=>$stack);
-            return true;
-        //===============
-        } else {
-            return $this->pfx($this->nfx($expr)); // straight up evaluation, woo
+          }
+          else { // did we somehow push a non-function on the stack? this should never happen
+            return $this->trigger("internal error");
+          }
         }
+        $index++;
+
+      }
+      elseif ($op == ',' and $expecting_op) { // did we just finish a function argument?
+        while (($o2 = $stack->pop()) != '(') {
+          if (is_null($o2)) {
+            return $this->trigger("unexpected ',' in $expr $o2");
+          } // oops, never had a (
+          else {
+            $output[] = $o2;
+          } // pop the argument expression stuff and push onto the output
+        }
+        // make sure there was a function
+        if (!preg_match("/^([a-z]\w*)\($/", $stack->last(2), $matches)) {
+          return $this->trigger("unexpected ','");
+        }
+        $stack->push($stack->pop() + 1); // increment the argument count
+        $stack->push('('); // put the ( back on, we'll need to pop back to it again
+        $index++;
+        $expecting_op = FALSE;
+
+      }
+      elseif ($op == '(' and !$expecting_op) {
+        $stack->push('('); // that was easy
+        $index++;
+        $allow_neg = TRUE;
+
+      }
+      elseif ($ex and !$expecting_op) { // do we now have a function/variable/number?
+        $expecting_op = TRUE;
+        $val = $match[1];
+        if (preg_match("/^([a-z]\w*)\($/", $val, $matches)) { // may be func, or variable w/ implicit multiplication against parentheses...
+          if (isset($this->fb[$matches[1]]) or array_key_exists($matches[1], $this->f)) { // it's a func
+            $stack->push($val);
+            $stack->push(1);
+            $stack->push('(');
+            $expecting_op = FALSE;
+          }
+          else { // it's a var w/ implicit multiplication
+            $val = $matches[1];
+            $output[] = $val;
+          }
+        }
+        else { // it's a plain old var or num
+          $output[] = $val;
+        }
+        $index += strlen($val);
+
+      }
+      elseif ($op == ')') { // miscellaneous error checking
+        return $this->trigger("unexpected ')'");
+      }
+      elseif (isset($ops[$op]) and !$expecting_op) {
+        return $this->trigger("unexpected operator '$op'");
+      }
+      elseif ($op == '"') {
+        // fetch a quoted string.
+        $string = substr($expr, $index);
+        if (preg_match('/"[^"\\\\]*(?:\\\\.[^"\\\\]*)*"/s', $string, $matches)) {
+          $string = $matches[0];
+          // trim the quotes off:
+          $output[] = $string;
+          $index += strlen($string);
+          $expecting_op = TRUE;
+        }
+        else {
+          return $this->trigger("open quote without close quote.");
+        }
+      }
+      else { // I don't even want to know what you did to get here
+        return $this->trigger("an unexpected error occured at $op");
+      }
+      if ($index == strlen($expr)) {
+        if (isset($ops[$op])) { // did we end with an operator? bad.
+          return $this->trigger("operator '$op' lacks operand");
+        }
+        else {
+          break;
+        }
+      }
+      while (substr($expr, $index, 1) == ' ') { // step the index past whitespace (pretty much turns whitespace
+        $index++; // into implicit multiplication if no operator is there)
+      }
     }
-
-    function vars() {
-        $output = $this->v;
-        unset($output['pi']);
-        unset($output['e']);
-        return $output;
-    }
-
-    function funcs() {
-        $output = array();
-        foreach ($this->f as $fnn=>$dat)
-            $output[] = $fnn . '(' . implode(',', $dat['args']) . ')';
-        return $output;
+    while (!is_null($op = $stack->pop())) { // pop everything off the stack and push onto output
+      if ($op == '(') {
+        return $this->trigger("expecting ')'");
+      } // if there are (s on the stack, ()s were unbalanced
+      $output[] = $op;
     }
 
-    //===================== HERE BE INTERNAL METHODS ====================\\
-
-    // Convert infix to postfix notation
-    function nfx($expr) {
+    return $output;
+  }
 
-        $index = 0;
-        $stack = new ctools_math_expr_stack;
-        $output = array(); // postfix form of expression, to be passed to pfx()
-        $expr = trim(strtolower($expr));
+  // evaluate postfix notation
+  function pfx($tokens, $vars = array()) {
 
-        $ops   = array('+', '-', '*', '/', '^', '_');
-        $ops_r = array('+'=>0,'-'=>0,'*'=>0,'/'=>0,'^'=>1); // right-associative operator?
-        $ops_p = array('+'=>0,'-'=>0,'*'=>1,'/'=>1,'_'=>1,'^'=>2); // operator precedence
+    if ($tokens == FALSE) {
+      return FALSE;
+    }
 
-        $expecting_op = false; // we use this in syntax-checking the expression
-                               // and determining when a - is a negation
+    $stack = new ctools_math_expr_stack;
 
-        if (preg_match("/[^\w\s+*^\/()\.,-]/", $expr, $matches)) { // make sure the characters are all good
-            return $this->trigger("illegal character '{$matches[0]}'");
+    foreach ($tokens as $token) { // nice and easy
+      // if the token is a binary operator, pop two values off the stack, do the operation, and push the result back on
+      if (in_array($token, array('+', '-', '*', '/', '^', '==', '!=', '<', '<=', '>=', '>'))) {
+        if (is_null($op2 = $stack->pop())) {
+          return $this->trigger("internal error");
         }
-
-        while(1) { // 1 Infinite Loop ;)
-            $op = substr($expr, $index, 1); // get the first character at the current index
-            // find out if we're currently at the beginning of a number/variable/function/parenthesis/operand
-            $ex = preg_match('/^([a-z]\w*\(?|\d+(?:\.\d*)?|\.\d+|\()/', substr($expr, $index), $match);
-            //===============
-            if ($op == '-' and !$expecting_op) { // is it a negation instead of a minus?
-                $stack->push('_'); // put a negation on the stack
-                $index++;
-            } elseif ($op == '_') { // we have to explicitly deny this, because it's legal on the stack
-                return $this->trigger("illegal character '_'"); // but not in the input expression
-            //===============
-            } elseif ((in_array($op, $ops) or $ex) and $expecting_op) { // are we putting an operator on the stack?
-                if ($ex) { // are we expecting an operator but have a number/variable/function/opening parethesis?
-                    $op = '*'; $index--; // it's an implicit multiplication
-                }
-                // heart of the algorithm:
-                while($stack->count > 0 and ($o2 = $stack->last()) and in_array($o2, $ops) and ($ops_r[$op] ? $ops_p[$op] < $ops_p[$o2] : $ops_p[$op] <= $ops_p[$o2])) {
-                    $output[] = $stack->pop(); // pop stuff off the stack into the output
-                }
-                // many thanks: http://en.wikipedia.org/wiki/Reverse_Polish_notation#The_algorithm_in_detail
-                $stack->push($op); // finally put OUR operator onto the stack
-                $index++;
-                $expecting_op = false;
-            //===============
-            } elseif ($op == ')' and $expecting_op) { // ready to close a parenthesis?
-                while (($o2 = $stack->pop()) != '(') { // pop off the stack back to the last (
-                    if (is_null($o2)) return $this->trigger("unexpected ')'");
-                    else $output[] = $o2;
-                }
-                if (preg_match("/^([a-z]\w*)\($/", $stack->last(2), $matches)) { // did we just close a function?
-                    $fnn = $matches[1]; // get the function name
-                    $arg_count = $stack->pop(); // see how many arguments there were (cleverly stored on the stack, thank you)
-                    $output[] = $stack->pop(); // pop the function and push onto the output
-                    if (in_array($fnn, $this->fb)) { // check the argument count
-                        if($arg_count > 1)
-                            return $this->trigger("too many arguments ($arg_count given, 1 expected)");
-                    } elseif (array_key_exists($fnn, $this->f)) {
-                        if ($arg_count != count($this->f[$fnn]['args']))
-                            return $this->trigger("wrong number of arguments ($arg_count given, " . count($this->f[$fnn]['args']) . " expected)");
-                    } else { // did we somehow push a non-function on the stack? this should never happen
-                        return $this->trigger("internal error");
-                    }
-                }
-                $index++;
-            //===============
-            } elseif ($op == ',' and $expecting_op) { // did we just finish a function argument?
-                while (($o2 = $stack->pop()) != '(') {
-                    if (is_null($o2)) return $this->trigger("unexpected ','"); // oops, never had a (
-                    else $output[] = $o2; // pop the argument expression stuff and push onto the output
-                }
-                // make sure there was a function
-                if (!preg_match("/^([a-z]\w*)\($/", $stack->last(2), $matches))
-                    return $this->trigger("unexpected ','");
-                $stack->push($stack->pop()+1); // increment the argument count
-                $stack->push('('); // put the ( back on, we'll need to pop back to it again
-                $index++;
-                $expecting_op = false;
-            //===============
-            } elseif ($op == '(' and !$expecting_op) {
-                $stack->push('('); // that was easy
-                $index++;
-                $allow_neg = true;
-            //===============
-            } elseif ($ex and !$expecting_op) { // do we now have a function/variable/number?
-                $expecting_op = true;
-                $val = $match[1];
-                if (preg_match("/^([a-z]\w*)\($/", $val, $matches)) { // may be func, or variable w/ implicit multiplication against parentheses...
-                    if (in_array($matches[1], $this->fb) or array_key_exists($matches[1], $this->f)) { // it's a func
-                        $stack->push($val);
-                        $stack->push(1);
-                        $stack->push('(');
-                        $expecting_op = false;
-                    } else { // it's a var w/ implicit multiplication
-                        $val = $matches[1];
-                        $output[] = $val;
-                    }
-                } else { // it's a plain old var or num
-                    $output[] = $val;
-                }
-                $index += strlen($val);
-            //===============
-            } elseif ($op == ')') { // miscellaneous error checking
-                return $this->trigger("unexpected ')'");
-            } elseif (in_array($op, $ops) and !$expecting_op) {
-                return $this->trigger("unexpected operator '$op'");
-            } else { // I don't even want to know what you did to get here
-                return $this->trigger("an unexpected error occured");
+        if (is_null($op1 = $stack->pop())) {
+          return $this->trigger("internal error");
+        }
+        switch ($token) {
+          case '+':
+            $stack->push($op1 + $op2);
+            break;
+          case '-':
+            $stack->push($op1 - $op2);
+            break;
+          case '*':
+            $stack->push($op1 * $op2);
+            break;
+          case '/':
+            if ($op2 == 0) {
+              return $this->trigger("division by zero");
             }
-            if ($index == strlen($expr)) {
-                if (in_array($op, $ops)) { // did we end with an operator? bad.
-                    return $this->trigger("operator '$op' lacks operand");
-                } else {
-                    break;
-                }
+            $stack->push($op1 / $op2);
+            break;
+          case '^':
+            $stack->push(pow($op1, $op2));
+            break;
+          case '==':
+            $stack->push(intval($op1 == $op2));
+            break;
+          case '!=':
+            $stack->push(intval($op1 != $op2));
+            break;
+          case '<=':
+            $stack->push(intval($op1 <= $op2));
+            break;
+          case '<':
+            $stack->push(intval($op1 < $op2));
+            break;
+          case '>=':
+            $stack->push(intval($op1 >= $op2));
+            break;
+          case '>':
+            $stack->push(intval($op1 > $op2));
+            break;
+        }
+        // if the token is a unary operator, pop one value off the stack, do the operation, and push it back on
+      }
+      elseif ($token == "_") {
+        $stack->push(-1 * $stack->pop());
+        // if the token is a function, pop arguments off the stack, hand them to the function, and push the result back on
+      }
+      elseif (preg_match("/^([a-z]\w*)\($/", $token, $matches)) { // it's a function!
+        $fnn = $matches[1];
+        if (isset($this->fb[$fnn])) { // built-in function:
+          $args = array();
+          for ($i = 0; $i < $this->fb[$fnn]['arguments']; $i++) {
+            if (is_null($op1 = $stack->pop())) {
+              return $this->trigger("function $fnn missing argument $i");
             }
-            while (substr($expr, $index, 1) == ' ') { // step the index past whitespace (pretty much turns whitespace
-                $index++;                             // into implicit multiplication if no operator is there)
+            $args[] = $op1;
+          }
+          if (!empty($this->fb[$fnn]['max arguments'])) {
+            for(;$i < $this->fb[$fnn]['max arguments']; $i++) {
+              $arg = $stack->pop();
+              if (!isset($arg)) {
+                break;
+              }
+              $args[] = $arg;
             }
+          }
 
+          $stack->push(call_user_func_array($this->fb[$fnn]['function'], array_reverse($args)));
         }
-        while (!is_null($op = $stack->pop())) { // pop everything off the stack and push onto output
-            if ($op == '(') return $this->trigger("expecting ')'"); // if there are (s on the stack, ()s were unbalanced
-            $output[] = $op;
-        }
-        return $output;
-    }
-
-    // evaluate postfix notation
-    function pfx($tokens, $vars = array()) {
-
-        if ($tokens == false) return false;
-
-        $stack = new ctools_math_expr_stack;
-
-        foreach ($tokens as $token) { // nice and easy
-            // if the token is a binary operator, pop two values off the stack, do the operation, and push the result back on
-            if (in_array($token, array('+', '-', '*', '/', '^'))) {
-                if (is_null($op2 = $stack->pop())) return $this->trigger("internal error");
-                if (is_null($op1 = $stack->pop())) return $this->trigger("internal error");
-                switch ($token) {
-                    case '+':
-                        $stack->push($op1+$op2); break;
-                    case '-':
-                        $stack->push($op1-$op2); break;
-                    case '*':
-                        $stack->push($op1*$op2); break;
-                    case '/':
-                        if ($op2 == 0) return $this->trigger("division by zero");
-                        $stack->push($op1/$op2); break;
-                    case '^':
-                        $stack->push(pow($op1, $op2)); break;
-                }
-            // if the token is a unary operator, pop one value off the stack, do the operation, and push it back on
-            } elseif ($token == "_") {
-                $stack->push(-1*$stack->pop());
-            // if the token is a function, pop arguments off the stack, hand them to the function, and push the result back on
-            } elseif (preg_match("/^([a-z]\w*)\($/", $token, $matches)) { // it's a function!
-                $fnn = $matches[1];
-                if (in_array($fnn, $this->fb)) { // built-in function:
-                    if (is_null($op1 = $stack->pop())) return $this->trigger("internal error");
-                    $fnn = preg_replace("/^arc/", "a", $fnn); // for the 'arc' trig synonyms
-                    if ($fnn == 'ln') $fnn = 'log';
-                    eval('$stack->push(' . $fnn . '($op1));'); // perfectly safe eval()
-                } elseif (array_key_exists($fnn, $this->f)) { // user function
-                    // get args
-                    $args = array();
-                    for ($i = count($this->f[$fnn]['args'])-1; $i >= 0; $i--) {
-                        if (is_null($args[$this->f[$fnn]['args'][$i]] = $stack->pop())) return $this->trigger("internal error");
-                    }
-                    $stack->push($this->pfx($this->f[$fnn]['func'], $args)); // yay... recursion!!!!
-                }
-            // if the token is a number or variable, push it on the stack
-            } else {
-                if (is_numeric($token)) {
-                    $stack->push($token);
-                } elseif (array_key_exists($token, $this->v)) {
-                    $stack->push($this->v[$token]);
-                } elseif (array_key_exists($token, $vars)) {
-                    $stack->push($vars[$token]);
-                } else {
-                    return $this->trigger("undefined variable '$token'");
-                }
+        elseif (isset($fnn, $this->f)) { // user function
+          // get args
+          $args = array();
+          for ($i = count($this->f[$fnn]['args']) - 1; $i >= 0; $i--) {
+            if (is_null($args[$this->f[$fnn]['args'][$i]] = $stack->pop())) {
+              return $this->trigger("internal error");
             }
+          }
+          $stack->push($this->pfx($this->f[$fnn]['func'], $args)); // yay... recursion!!!!
+        }
+        // if the token is a number or variable, push it on the stack
+      }
+      else {
+        if (is_numeric($token) || $token[0] == '"') {
+          $stack->push($token);
+        }
+        elseif (array_key_exists($token, $this->v)) {
+          $stack->push($this->v[$token]);
+        }
+        elseif (array_key_exists($token, $vars)) {
+          $stack->push($vars[$token]);
+        }
+        else {
+          return $this->trigger("undefined variable '$token'");
         }
-        // when we're out of tokens, the stack should have a single element, the final result
-        if ($stack->count != 1) return $this->trigger("internal error");
-        return $stack->pop();
+      }
     }
+    // when we're out of tokens, the stack should have a single element, the final result
+    if ($stack->count != 1) {
+      return $this->trigger("internal error");
+    }
+
+    return $stack->pop();
+  }
 
-    // trigger an error, but nicely, if need be
-    function trigger($msg) {
-        $this->last_error = $msg;
-        if (!$this->suppress_errors) trigger_error($msg, E_USER_WARNING);
-        return false;
+  // trigger an error, but nicely, if need be
+  function trigger($msg) {
+    $this->errors[] = $msg;
+    $this->last_error = $msg;
+    if (!$this->suppress_errors) {
+      trigger_error($msg, E_USER_WARNING);
     }
+
+    return FALSE;
+  }
 }
 
 // for internal use
 class ctools_math_expr_stack {
 
-    var $stack = array();
-    var $count = 0;
+  var $stack = array();
+  var $count = 0;
 
-    function push($val) {
-        $this->stack[$this->count] = $val;
-        $this->count++;
-    }
+  function push($val) {
+    $this->stack[$this->count] = $val;
+    $this->count++;
+  }
 
-    function pop() {
-        if ($this->count > 0) {
-            $this->count--;
-            return $this->stack[$this->count];
-        }
-        return null;
-    }
+  function pop() {
+    if ($this->count > 0) {
+      $this->count--;
 
-    function last($n=1) {
-        return !empty($this->stack[$this->count-$n]) ? $this->stack[$this->count-$n] : NULL;
+      return $this->stack[$this->count];
     }
+
+    return NULL;
+  }
+
+  function last($n = 1) {
+    return !empty($this->stack[$this->count - $n]) ? $this->stack[$this->count - $n] : NULL;
+  }
+}
+
+function ctools_math_expr_if($expr, $if, $else = NULL) {
+  return $expr ? $if : $else;
 }
 
+function ctools_math_expr_number($arg) {
+  // Remove any non-digits so that numbers like $4,511.23 still work.
+  // @todo: locale could break this sincein some locales that's $4.512,33
+  // so there needs to be a way to detect that and make it work properly.
+  $arg = preg_replace("/[^0-9\.]/", '', $arg);
+  return $arg;
+}
\ No newline at end of file
diff --git a/tests/math_expression.test b/tests/math_expression.test
index 730e079..cec975c 100644
--- a/tests/math_expression.test
+++ b/tests/math_expression.test
@@ -39,31 +39,31 @@ class CtoolsMathExpressionTestCase extends DrupalWebTestCase {
     $math_expression = new ctools_math_expr();
 
     // Test constant expressions.
-    $this->assertEqual($math_expression->e('2'), 2);
+    $this->assertEqual($math_expression->evaluate('2'), 2);
     $random_number = rand(0, 10);
-    $this->assertEqual($random_number, $math_expression->e((string) $random_number));
+    $this->assertEqual($random_number, $math_expression->evaluate((string) $random_number));
 
     // Test simple arithmetic.
     $random_number_a = rand(5, 10);
     $random_number_b = rand(5, 10);
-    $this->assertEqual($random_number_a + $random_number_b, $math_expression->e("$random_number_a + $random_number_b"));
-    $this->assertEqual($random_number_a - $random_number_b, $math_expression->e("$random_number_a - $random_number_b"));
-    $this->assertEqual($random_number_a * $random_number_b, $math_expression->e("$random_number_a * $random_number_b"));
-    $this->assertEqual($random_number_a / $random_number_b, $math_expression->e("$random_number_a / $random_number_b"));
+    $this->assertEqual($random_number_a + $random_number_b, $math_expression->evaluate("$random_number_a + $random_number_b"));
+    $this->assertEqual($random_number_a - $random_number_b, $math_expression->evaluate("$random_number_a - $random_number_b"));
+    $this->assertEqual($random_number_a * $random_number_b, $math_expression->evaluate("$random_number_a * $random_number_b"));
+    $this->assertEqual(round($random_number_a / $random_number_b, 8), round($math_expression->evaluate("$random_number_a / $random_number_b"), 8));
 
     // Test Associative property.
     $random_number_c = rand(5, 10);
-    $this->assertEqual($math_expression->e("$random_number_a + ($random_number_b + $random_number_c)"), $math_expression->e("($random_number_a + $random_number_b) + $random_number_c"));
-    $this->assertEqual($math_expression->e("$random_number_a * ($random_number_b * $random_number_c)"), $math_expression->e("($random_number_a * $random_number_b) * $random_number_c"));
+    $this->assertEqual($math_expression->evaluate("$random_number_a + ($random_number_b + $random_number_c)"), $math_expression->evaluate("($random_number_a + $random_number_b) + $random_number_c"));
+    $this->assertEqual($math_expression->evaluate("$random_number_a * ($random_number_b * $random_number_c)"), $math_expression->evaluate("($random_number_a * $random_number_b) * $random_number_c"));
 
     // Test Commutative property.
-    $this->assertEqual($math_expression->e("$random_number_a + $random_number_b"), $math_expression->e("$random_number_b + $random_number_a"));
-    $this->assertEqual($math_expression->e("$random_number_a * $random_number_b"), $math_expression->e("$random_number_b * $random_number_a"));
+    $this->assertEqual($math_expression->evaluate("$random_number_a + $random_number_b"), $math_expression->evaluate("$random_number_b + $random_number_a"));
+    $this->assertEqual($math_expression->evaluate("$random_number_a * $random_number_b"), $math_expression->evaluate("$random_number_b * $random_number_a"));
 
     // Test Distributive property.
-    $this->assertEqual($math_expression->e("($random_number_a + $random_number_b) * $random_number_c"), $math_expression->e("($random_number_a * $random_number_c + $random_number_b * $random_number_c)"));
+    $this->assertEqual($math_expression->evaluate("($random_number_a + $random_number_b) * $random_number_c"), $math_expression->evaluate("($random_number_a * $random_number_c + $random_number_b * $random_number_c)"));
 
-    $this->assertEqual(pow($random_number_a, $random_number_b), $math_expression->e("$random_number_a ^ $random_number_b"));
+    $this->assertEqual(pow($random_number_a, $random_number_b), $math_expression->evaluate("$random_number_a ^ $random_number_b"));
   }
 
   public function testBuildInFunctions() {
@@ -72,26 +72,25 @@ class CtoolsMathExpressionTestCase extends DrupalWebTestCase {
     // @todo: maybe run this code multiple times to test different values.
     $random_double = $this->rand01();
     $random_int = rand(5, 10);
-    $this->assertFloat(sin($random_double), $math_expression->e("sin($random_double)"));
-    $this->assertFloat(cos($random_double), $math_expression->e("cos($random_double)"));
-    $this->assertFloat(tan($random_double), $math_expression->e("tan($random_double)"));
-    $this->assertFloat(exp($random_double), $math_expression->e("exp($random_double)"));
-    $this->assertFloat(sqrt($random_double), $math_expression->e("sqrt($random_double)"));
-    $this->assertFloat(log($random_double), $math_expression->e("ln($random_double)"));
-    $this->assertFloat(round($random_double), $math_expression->e("round($random_double)"));
-    $this->assertFloat(abs($random_double + $random_int), $math_expression->e('abs(' . ($random_double + $random_int) . ')'));
-    $this->assertEqual(round($random_double + $random_int), $math_expression->e('round(' . ($random_double + $random_int) . ')'));
-    $this->assertEqual(ceil($random_double + $random_int), $math_expression->e('ceil(' . ($random_double + $random_int) . ')'));
-    $this->assertEqual(floor($random_double + $random_int), $math_expression->e('floor(' . ($random_double + $random_int) . ')'));
+    $this->assertFloat(sin($random_double), $math_expression->evaluate("sin($random_double)"));
+    $this->assertFloat(cos($random_double), $math_expression->evaluate("cos($random_double)"));
+    $this->assertFloat(tan($random_double), $math_expression->evaluate("tan($random_double)"));
+    $this->assertFloat(exp($random_double), $math_expression->evaluate("exp($random_double)"));
+    $this->assertFloat(sqrt($random_double), $math_expression->evaluate("sqrt($random_double)"));
+    $this->assertFloat(log($random_double), $math_expression->evaluate("ln($random_double)"));
+    $this->assertFloat(round($random_double), $math_expression->evaluate("round($random_double)"));
+    $this->assertFloat(abs($random_double + $random_int), $math_expression->evaluate('abs(' . ($random_double + $random_int) . ')'));
+    $this->assertEqual(round($random_double + $random_int), $math_expression->evaluate('round(' . ($random_double + $random_int) . ')'));
+    $this->assertEqual(ceil($random_double + $random_int), $math_expression->evaluate('ceil(' . ($random_double + $random_int) . ')'));
+    $this->assertEqual(floor($random_double + $random_int), $math_expression->evaluate('floor(' . ($random_double + $random_int) . ')'));
 
     // @fixme: you can't run time without an argument.
-    $this->assertFloat(time(), $math_expression->e('time(1)'));
+    $this->assertFloat(time(), $math_expression->evaluate('time(1)'));
 
     $random_double_a = $this->rand01();
     $random_double_b = $this->rand01();
-    // @fixme: max/min don't work at the moment.
-//    $this->assertFloat(max($random_double_a, $random_double_b), $math_expression->e("max($random_double_a, $random_double_b)"));
-//    $this->assertFloat(min($random_double_a, $random_double_b), $math_expression->e("min($random_double_a, $random_double_b)"));
+    $this->assertFloat(max($random_double_a, $random_double_b), $math_expression->evaluate("max($random_double_a, $random_double_b)"));
+    $this->assertFloat(min($random_double_a, $random_double_b), $math_expression->evaluate("min($random_double_a, $random_double_b)"));
   }
 
   public function testVariables() {
@@ -101,11 +100,11 @@ class CtoolsMathExpressionTestCase extends DrupalWebTestCase {
     $random_number_b = rand(5, 10);
 
     // Store the first random number and use it on calculations.
-    $math_expression->e("var = $random_number_a");
-    $this->assertEqual($random_number_a + $random_number_b, $math_expression->e("var + $random_number_b"));
-    $this->assertEqual($random_number_a * $random_number_b, $math_expression->e("var * $random_number_b"));
-    $this->assertEqual($random_number_a - $random_number_b, $math_expression->e("var - $random_number_b"));
-    $this->assertEqual($random_number_a / $random_number_b, $math_expression->e("var / $random_number_b"));
+    $math_expression->evaluate("var = $random_number_a");
+    $this->assertEqual($random_number_a + $random_number_b, $math_expression->evaluate("var + $random_number_b"));
+    $this->assertEqual($random_number_a * $random_number_b, $math_expression->evaluate("var * $random_number_b"));
+    $this->assertEqual($random_number_a - $random_number_b, $math_expression->evaluate("var - $random_number_b"));
+    $this->assertEqual(round($random_number_a / $random_number_b, 8), round($math_expression->evaluate("var / $random_number_b"), 8));
   }
 
   public function testCustomFunctions() {
@@ -115,15 +114,31 @@ class CtoolsMathExpressionTestCase extends DrupalWebTestCase {
     $random_number_b = rand(5, 10);
 
     // Create a one-argument function.
-    $math_expression->e("f(x) = 2 * x");
-    $this->assertEqual($random_number_a * 2, $math_expression->e("f($random_number_a)"));
-    $this->assertEqual($random_number_b * 2, $math_expression->e("f($random_number_b)"));
+    $math_expression->evaluate("f(x) = 2 * x");
+    $this->assertEqual($random_number_a * 2, $math_expression->evaluate("f($random_number_a)"));
+    $this->assertEqual($random_number_b * 2, $math_expression->evaluate("f($random_number_b)"));
 
     // Create a two-argument function.
-    $math_expression->e("g(x, y) = 2 * x + y");
-    $this->assertEqual($random_number_a * 2 + $random_number_b, $math_expression->e("g($random_number_a, $random_number_b)"));
+    $math_expression->evaluate("g(x, y) = 2 * x + y");
+    $this->assertEqual($random_number_a * 2 + $random_number_b, $math_expression->evaluate("g($random_number_a, $random_number_b)"));
 
     // Use a custom function in another function.
-    $this->assertEqual(($random_number_a * 2 + $random_number_b) * 2, $math_expression->e("f(g($random_number_a, $random_number_b))"));
+    $this->assertEqual(($random_number_a * 2 + $random_number_b) * 2, $math_expression->evaluate("f(g($random_number_a, $random_number_b))"));
   }
+
+  public function testIf() {
+    $math_expression = new ctools_math_expr();
+
+    $random_number_a = rand(1, 5);
+    $random_number_b = rand(10, 20);
+
+    $this->assertEqual($math_expression->evaluate("if(1, $random_number_a, $random_number_b)"), $random_number_a);
+    $this->assertEqual($math_expression->evaluate("if(1, $random_number_a)"), $random_number_a);
+
+    $this->assertEqual($math_expression->evaluate("if(0, $random_number_a, $random_number_b)"), $random_number_b);
+
+    // Also add an expression so ensure it's evaluated.
+    $this->assertEqual($math_expression->evaluate("if($random_number_a > $random_number_b, $random_number_a, $random_number_b)"), $random_number_b);
+  }
+
 }
